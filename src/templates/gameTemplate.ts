/**
 * Game Template for AI-Generated Games
 * 
 * This template provides a standardized structure for creating games
 * that can be dynamically generated by an LLM and loaded into the app.
 * 
 * Based on: SpaceInvadersGame.tsx and ThisIsFineGame.tsx
 */

export const GAME_TEMPLATE = `
'use client';

import React, { useState, useEffect, useRef, useCallback } from 'react';

/**
 * GAME STRUCTURE TEMPLATE
 * 
 * Required Features:
 * 1. Responsive design (mobile + desktop)
 * 2. Canvas-based rendering
 * 3. Game state management (playing, gameOver, won)
 * 4. Score tracking
 * 5. Reset/restart functionality
 * 6. Touch and keyboard controls
 * 
 * Game Dimensions:
 * - Desktop: 320-420px width, 320-560px height
 * - Mobile: Full screen (window.innerWidth, window.innerHeight)
 */

// Define your game interfaces here
interface GameObject {
  x: number;
  y: number;
  width: number;
  height: number;
  // Add other properties as needed
}

interface GameState {
  // Define your game state properties
}

const GeneratedGame: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const rafRef = useRef<number | null>(null);
  
  // Game dimensions - responsive
  const [gameWidth, setGameWidth] = useState(320);
  const [gameHeight, setGameHeight] = useState(320);
  const [isMobile, setIsMobile] = useState(false);
  
  // Game state
  const [gameState, setGameState] = useState<'playing' | 'gameOver' | 'won'>('playing');
  const [score, setScore] = useState(0);
  
  // Game objects (use refs for real-time updates in game loop)
  const gameObjectsRef = useRef<any>({
    // Initialize your game objects here
  });

  // 1. Initialize responsive dimensions
  useEffect(() => {
    const updateDimensions = () => {
      const mobile = window.innerWidth <= 768 || 'ontouchstart' in window;
      setIsMobile(mobile);
      setGameWidth(mobile ? window.innerWidth : 320);
      setGameHeight(mobile ? window.innerHeight : 320);
    };
    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    return () => window.removeEventListener('resize', updateDimensions);
  }, []);

  // 2. Initialize canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    const dpr = window.devicePixelRatio || 1;
    canvas.width = gameWidth * dpr;
    canvas.height = gameHeight * dpr;
    ctx.scale(dpr, dpr);
    
    canvas.style.width = gameWidth + 'px';
    canvas.style.height = gameHeight + 'px';
  }, [gameWidth, gameHeight]);

  // 3. Game loop
  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      // Update game logic here
      // - Move objects
      // - Check collisions
      // - Update score
      // - Check win/lose conditions
      
      // Example:
      // setGameObjects(prev => {
      //   // Update logic
      //   return updatedObjects;
      // });
    }, 1000 / 60); // 60 FPS

    return () => clearInterval(gameLoop);
  }, [gameState, gameWidth, gameHeight]);

  // 4. Keyboard controls
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (gameState !== 'playing') return;
      
      // Prevent default for game keys
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      // Handle controls
      switch (e.key) {
        case 'ArrowLeft':
          // Move left
          break;
        case 'ArrowRight':
          // Move right
          break;
        case 'ArrowUp':
          // Move up or jump
          break;
        case 'ArrowDown':
          // Move down
          break;
        case ' ':
          // Shoot or action
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [gameState]);

  // 5. Touch controls (mobile)
  const handleTouch = useCallback((e: React.TouchEvent) => {
    if (gameState !== 'playing') return;
    
    const canvas = canvasRef.current;
    if (!canvas) return;

    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;

    // Handle touch input
    // Example: Move player to touch position
  }, [gameState, gameWidth]);

  // 6. Draw function
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Clear canvas
    ctx.fillStyle = '#000000'; // Background color
    ctx.fillRect(0, 0, gameWidth, gameHeight);
    
    // Draw game objects
    // Example:
    // ctx.fillStyle = '#ffffff';
    // ctx.fillRect(x, y, width, height);
    
    // Draw score
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Courier New"';
    ctx.fillText(\`Score: \${score}\`, 10, 25);
    
    // Draw game over screen
    if (gameState === 'gameOver') {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(0, 0, gameWidth, gameHeight);
      ctx.fillStyle = '#ff0000';
      ctx.font = '24px "Courier New"';
      const text = 'GAME OVER';
      ctx.fillText(text, gameWidth / 2 - ctx.measureText(text).width / 2, gameHeight / 2);
    }
    
    // Draw win screen
    if (gameState === 'won') {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(0, 0, gameWidth, gameHeight);
      ctx.fillStyle = '#00ff00';
      ctx.font = '24px "Courier New"';
      const text = 'YOU WIN!';
      ctx.fillText(text, gameWidth / 2 - ctx.measureText(text).width / 2, gameHeight / 2);
    }
  }, [gameState, score, gameWidth, gameHeight]);

  // 7. Reset game
  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    // Reset game objects
    gameObjectsRef.current = {
      // Re-initialize objects
    };
  };

  return (
    <div className={\`min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 \${isMobile ? 'p-0' : 'p-4'}\`}>
      {/* Game Title */}
      {!isMobile && (
        <div className="text-center mb-4">
          <h1 className="text-3xl font-bold text-white font-mono">GAME TITLE</h1>
        </div>
      )}

      {/* Game Canvas */}
      <div className={\`flex justify-center \${isMobile ? 'h-screen' : 'mb-4'}\`}>
        <div className="relative w-full h-full">
          <canvas
            ref={canvasRef}
            className={isMobile ? '' : 'border-2 border-blue-500 rounded-lg'}
            style={{
              backgroundColor: '#0a0a2e',
              width: \`\${gameWidth}px\`,
              height: \`\${gameHeight}px\`,
              touchAction: 'none',
              imageRendering: 'pixelated',
            }}
            onTouchStart={isMobile ? handleTouch : undefined}
            onTouchMove={isMobile ? handleTouch : undefined}
          />
          
          {(gameState === 'gameOver' || gameState === 'won') && (
            <button
              onClick={resetGame}
              className="absolute top-1/2 left-1/2 transform -translate-x-1/2 translate-y-20 bg-red-500 text-white font-mono font-bold px-4 py-2 rounded hover:bg-red-600 transition-all duration-300"
            >
              RESTART
            </button>
          )}
        </div>
      </div>
    </div>
  );
};

export default GeneratedGame;
`;

export const GAME_GENERATION_SYSTEM_PROMPT = `You are an expert game developer specializing in creating browser-based canvas games using React and TypeScript.

Your task is to generate a complete, working game component based on the user's description.

REQUIREMENTS:
1. The game MUST be a React functional component using TypeScript
2. Use canvas for rendering (no DOM-based game elements)
3. Support both desktop (keyboard) and mobile (touch) controls
4. Be responsive: desktop ~320-420px, mobile full-screen
5. Include game states: 'playing', 'gameOver', 'won'
6. Include score tracking
7. Use requestAnimationFrame or setInterval for game loop
8. Include a restart button when game ends
9. Follow the exact structure of the provided template
10. Use refs for real-time game state (gameObjectsRef)

GAME TEMPLATE STRUCTURE:
- Game should be self-contained in a single component
- Use the same patterns as SpaceInvadersGame and ThisIsFineGame
- Include proper TypeScript interfaces for game objects
- Use 'use client' directive at the top
- Export default the game component

STYLING:
- Use Tailwind CSS classes for layout
- Use canvas 2D context for game rendering
- Background: gradient from slate-900 via purple-900
- Retro/pixel art style preferred
- Monospace fonts (Courier New)

CONTROLS:
- Desktop: Arrow keys for movement, Space for action
- Mobile: Touch to control (tap, drag, or buttons)
- Both must work seamlessly

CODE QUALITY:
- Clean, readable code with comments
- Type-safe TypeScript
- Proper cleanup of event listeners
- Performance optimized (60 FPS target)

Return ONLY the complete .tsx file content, nothing else. No markdown, no explanations.`;

export const EXAMPLE_USER_PROMPTS = [
  "A flappy bird clone where you tap to make a bird fly through pipes",
  "A breakout/brick breaker game with paddle and ball physics",
  "A snake game that gets longer as it eats food",
  "A platformer where you jump on platforms to reach the top",
  "A racing game where you dodge cars coming at you",
  "A puzzle game where you match colors in a grid",
  "A tower defense game with different types of enemies",
  "An endless runner where you avoid obstacles"
];

