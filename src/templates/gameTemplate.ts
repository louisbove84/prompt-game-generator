/**
 * Game Template for AI-Generated Games
 * 
 * This template provides a standardized structure for creating games
 * that can be dynamically generated by an LLM and loaded into the app.
 * 
 * Based on: SpaceInvadersGame.tsx and ThisIsFineGame.tsx
 */

export const GAME_TEMPLATE = `
'use client';

import React, { useState, useEffect, useRef, useCallback } from 'react';

/**
 * GAME STRUCTURE TEMPLATE
 * 
 * Required Features:
 * 1. Responsive design (mobile + desktop)
 * 2. Canvas-based rendering
 * 3. Game state management (playing, gameOver, won)
 * 4. Score tracking
 * 5. Reset/restart functionality
 * 6. Touch and keyboard controls
 * 
 * Game Dimensions:
 * - Desktop: 320-420px width, 320-560px height
 * - Mobile: Full screen (window.innerWidth, window.innerHeight)
 */

// Define your game interfaces here
interface GameObject {
  x: number;
  y: number;
  width: number;
  height: number;
  // Add other properties as needed
}

interface GameState {
  // Define your game state properties
}

const GeneratedGame: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const rafRef = useRef<number | null>(null);
  
  // Game dimensions - responsive
  const [gameWidth, setGameWidth] = useState(320);
  const [gameHeight, setGameHeight] = useState(320);
  const [isMobile, setIsMobile] = useState(false);
  
  // Game state
  const [gameState, setGameState] = useState<'playing' | 'gameOver' | 'won'>('playing');
  const [score, setScore] = useState(0);
  
  // Game objects (use refs for real-time updates in game loop)
  const gameObjectsRef = useRef<any>({
    // Initialize your game objects here
  });

  // 1. Initialize responsive dimensions
  useEffect(() => {
    const updateDimensions = () => {
      const mobile = window.innerWidth <= 768 || 'ontouchstart' in window;
      setIsMobile(mobile);
      setGameWidth(mobile ? window.innerWidth : 320);
      setGameHeight(mobile ? window.innerHeight : 320);
    };
    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    return () => window.removeEventListener('resize', updateDimensions);
  }, []);

  // 2. Initialize canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    const dpr = window.devicePixelRatio || 1;
    canvas.width = gameWidth * dpr;
    canvas.height = gameHeight * dpr;
    ctx.scale(dpr, dpr);
    
    canvas.style.width = gameWidth + 'px';
    canvas.style.height = gameHeight + 'px';
  }, [gameWidth, gameHeight]);

  // 3. Game loop - PERFORMANCE CRITICAL
  useEffect(() => {
    if (gameState !== 'playing') return;

    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const gameLoop = setInterval(() => {
      const objects = gameObjectsRef.current;
      
      // UPDATE: Modify objects directly in ref (NO setState here!)
      // - Move objects
      // - Check collisions
      // - Increment score in ref
      
      // DRAW: Draw everything to canvas
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, gameWidth, gameHeight);
      
      // Draw game objects using ctx methods
      // ctx.fillRect(...), ctx.arc(...), etc.
      
      // Check game over condition
      // if (collision) {
      //   setGameState('gameOver'); // setState is OK here - happens once
      // }
    }, 1000 / 60); // 60 FPS

    return () => clearInterval(gameLoop);
  }, [gameState, gameWidth, gameHeight]);

  // 4. Keyboard controls (Desktop/Browser ONLY)
  useEffect(() => {
    // Only enable keyboard controls on desktop (non-touch devices)
    if (isMobile) return;
    
    const handleKeyDown = (e: KeyboardEvent) => {
      if (gameState !== 'playing') return;
      
      // Prevent default for game keys
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      // Handle controls - Arrow keys for movement, Space for action
      switch (e.key) {
        case 'ArrowLeft':
          // Move left
          break;
        case 'ArrowRight':
          // Move right
          break;
        case 'ArrowUp':
          // Move up or jump
          break;
        case 'ArrowDown':
          // Move down
          break;
        case ' ':
          // Shoot or action (Space bar)
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [gameState, isMobile]);

  // 5. Touch controls (Mobile/Frame ONLY)
  const handleTouch = useCallback((e: React.TouchEvent) => {
    // Only enable touch controls on mobile/frame
    if (!isMobile) return;
    if (gameState !== 'playing') return;
    
    const canvas = canvasRef.current;
    if (!canvas) return;

    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;

    // Handle touch input - tap anywhere to jump/shoot, or use touch position
    // Example: Tap to jump/action
    e.preventDefault();
  }, [gameState, gameWidth, isMobile]);

  // 6. Draw game over/won screens (only when NOT playing)
  useEffect(() => {
    if (gameState === 'playing') return;
    
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Draw overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, gameWidth, gameHeight);
    
    // Draw text
    ctx.fillStyle = gameState === 'gameOver' ? '#ff0000' : '#00ff00';
    ctx.font = '24px "Courier New"';
    const text = gameState === 'gameOver' ? 'GAME OVER' : 'YOU WIN!';
    ctx.fillText(text, gameWidth / 2 - ctx.measureText(text).width / 2, gameHeight / 2);
  }, [gameState, gameWidth, gameHeight]);

  // 7. Reset game
  const resetGame = () => {
    setGameState('playing');
    setScore(0);
    // Reset game objects
    gameObjectsRef.current = {
      // Re-initialize objects
    };
  };

  return (
    <div className={\`min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 \${isMobile ? 'p-0' : 'p-4'}\`}>
      {/* Game Title */}
      {!isMobile && (
        <div className="text-center mb-4">
          <h1 className="text-3xl font-bold text-white font-mono">GAME TITLE</h1>
        </div>
      )}

      {/* Game Canvas */}
      <div className={\`flex justify-center \${isMobile ? 'h-screen' : 'mb-4'}\`}>
        <div className="relative w-full h-full">
          <canvas
            ref={canvasRef}
            className={isMobile ? '' : 'border-2 border-blue-500 rounded-lg'}
            style={{
              backgroundColor: '#0a0a2e',
              width: \`\${gameWidth}px\`,
              height: \`\${gameHeight}px\`,
              touchAction: 'none',
              imageRendering: 'pixelated',
            }}
            onTouchStart={isMobile ? handleTouch : undefined}
            onTouchMove={isMobile ? handleTouch : undefined}
          />
          
          {(gameState === 'gameOver' || gameState === 'won') && (
            <button
              onClick={resetGame}
              className="absolute top-1/2 left-1/2 transform -translate-x-1/2 translate-y-20 bg-red-500 text-white font-mono font-bold px-4 py-2 rounded hover:bg-red-600 transition-all duration-300"
            >
              RESTART
            </button>
          )}
        </div>
      </div>
    </div>
  );
};

export default GeneratedGame;
`;

export const GAME_GENERATION_SYSTEM_PROMPT = `You are an expert game developer specializing in creating browser-based canvas games using React and TypeScript.

Your task is to generate a complete, working game component based on the user's description.

CRITICAL REQUIREMENTS - READ CAREFULLY:

1. The game MUST be a React functional component using TypeScript
2. Use canvas for ALL rendering - no DOM-based game elements

3. **JSX and Layout**:
   ✅ You can use normal React JSX in the return statement
   ✅ Use standard HTML elements: <div>, <canvas>, <button>, <h1>, etc.
   ✅ Use Tailwind CSS classes for styling
   
   ⚠️ IMPORTANT: Game rendering MUST still use Canvas 2D API
   - ALL game graphics (sprites, enemies, projectiles, etc.) MUST use ctx.fillRect(), ctx.arc(), ctx.drawImage(), etc.
   - Game titles/UI CAN be JSX (e.g., <h1 className="...">Game Title</h1>)
   - Buttons, menus, overlays CAN be JSX
   - But the actual GAME OBJECTS must render to canvas

4. **NO CUSTOM JSX COMPONENTS** - everything must render to canvas
5. All game graphics MUST use canvas 2D context: ctx.fillRect(), ctx.arc(), ctx.drawImage(), etc.
6. **CRITICAL**: Implement platform-specific controls:
   - Desktop: ONLY keyboard (Arrow keys + Space bar)
   - Mobile/Frame: ONLY touch (onTouchStart on canvas)
   - Check isMobile flag to enable the correct control scheme
   - Keyboard controls should NOT work on mobile, touch should NOT work on desktop
7. Be responsive: desktop ~320-420px, mobile full-screen
8. Include game states: 'playing', 'gameOver', 'won'
9. Include score tracking
10. Use setInterval for game loop (60 FPS)
11. **PERFORMANCE**: Keep ALL game logic and drawing INSIDE the game loop interval
    - Do NOT use separate useEffect for drawing with score dependencies
    - Do NOT call setState inside the game loop (except for game over)
    - Store score in ref, only update state when game ends
12. Follow the EXACT structure of SpaceInvadersGame and ThisIsFineGame templates
13. Use refs for real-time game state (gameObjectsRef)
14. The component will be dynamically loaded - keep it simple and working

GAME TEMPLATE STRUCTURE:
- Game should be self-contained in a single component
- Use the same patterns as SpaceInvadersGame and ThisIsFineGame
- Include proper TypeScript interfaces for game objects
- Use 'use client' directive at the top
- Export default the game component

STYLING:
- Use Tailwind CSS classes for layout
- Use canvas 2D context for game rendering
- Background: gradient from slate-900 via purple-900
- Retro/pixel art style preferred
- Monospace fonts (Courier New)

CONTROLS:
- **Desktop/Browser ONLY**: Arrow keys for movement, Space bar for action/jump
  * Use \`window.addEventListener\` for keyboard controls
  * Arrow keys: ArrowUp, ArrowDown, ArrowLeft, ArrowRight
  * Space bar for action
- **Mobile/Frame ONLY**: Touch controls (tap screen or on-screen buttons)
  * Use onTouchStart, onTouchMove, onTouchEnd events on the canvas
  * Detect mobile with window.innerWidth or ontouchstart check
- Implement BOTH control schemes - keyboard for desktop, touch for mobile
- NO cross-platform controls (e.g., clicking on desktop should not trigger game actions)

CODE QUALITY:
- Clean, readable code with comments
- Type-safe TypeScript
- Proper cleanup of event listeners
- **CRITICAL PERFORMANCE**:
  * Use refs for game state (gameObjectsRef) - NEVER use setState in game loop
  * Draw function should NOT be in useEffect with dependencies on score/state
  * Game loop should call draw() directly, not trigger re-renders
  * Only use setState for UI changes (game over screen, final score display)
  * Target: Solid 60 FPS performance

Return ONLY the complete .tsx file content, nothing else. No markdown, no explanations.`;

export const EXAMPLE_USER_PROMPTS = [
  "A flappy bird clone where you tap to make a bird fly through pipes",
  "A breakout/brick breaker game with paddle and ball physics",
  "A snake game that gets longer as it eats food",
  "A platformer where you jump on platforms to reach the top",
  "A racing game where you dodge cars coming at you",
  "A puzzle game where you match colors in a grid",
  "A tower defense game with different types of enemies",
  "An endless runner where you avoid obstacles"
];

